#!/usr/bin/env bash
# bin/package - CLI principal atualizado
# - Carrega módulos em MODULEDIR
# - Suporta aliases/abreviações
# - Coloração condicional
# - Expondo register list/info (via register.sh)

set -euo pipefail
IFS=$'\n\t'

# Load global config if present
[ -f /etc/package.conf ] && source /etc/package.conf

MODULEDIR=${MODULEDIR:-/opt/package/modules}
PORTSDIR=${PORTSDIR:-/usr/ports}
PREFIX=${PREFIX:-/usr/local}

# Colors
if [ "${COLOR_OUTPUT:-yes}" = "yes" ] && [ -t 1 ]; then
  COLOR_RESET="\033[0m"
  COLOR_RED="${COLOR_ERROR:-\033[31m}"
  COLOR_GREEN="${COLOR_INFO:-\033[32m}"
  COLOR_YELLOW="${COLOR_WARN:-\033[33m}"
  COLOR_CYAN="\033[36m"
else
  COLOR_RESET=""; COLOR_RED=""; COLOR_GREEN=""; COLOR_YELLOW=""; COLOR_CYAN=""
fi

log()  { printf '%b\n' "${COLOR_CYAN}[package]${COLOR_RESET} $*"; }
info() { printf '%b\n' "${COLOR_GREEN}[INFO]${COLOR_RESET} $*"; }
warn() { printf '%b\n' "${COLOR_YELLOW}[WARN]${COLOR_RESET} $*"; }
err()  { printf '%b\n' "${COLOR_RED}[ERROR]${COLOR_RESET} $*" >&2; }

# Load modules: source all *.sh under MODULEDIR if enabled
load_modules() {
  [ -d "$MODULEDIR" ] || return 0
  for m in "$MODULEDIR"/*.sh; do
    [ -r "$m" ] || continue
    # don't error out if file missing
    # shellcheck disable=SC1090
    source "$m"
  done
}

# Aliases mapping (can be overridden by /etc/package.conf ALIASES)
ALIASES=${ALIASES:-${ALIAS_MAP:-"f:fetch b:build i:install r:remove u:upgrade d:deps upd:update full:full reg:register"}}

resolve_cmd() {
  local cmd="$1"
  # expand aliases
  for a in $ALIASES; do
    IFS=':' read -r key val <<< "$a"
    if [ "$cmd" = "$key" ]; then
      echo "$val"
      return 0
    fi
  done
  case "$cmd" in
    h|help|--help) echo "help"; return 0 ;;
    *) echo "$cmd"; return 0 ;;
  esac
}

usage() {
  cat <<EOF
${COLOR_CYAN}Uso:${COLOR_RESET} package <comando> [args]

Comandos comuns:
  fetch (f)        build (b)       install (i)     remove (r)
  upgrade (u)      update (upd)    deps (d)        full
  list, ls         service (srv)   sync
  register (reg) list|info <port>  # register list/info
  help (h)

Ex.: package full lang/gcc
     package reg list
     package register info lang/gcc
EOF
}

main() {
  if [ $# -lt 1 ]; then
    usage
    exit 1
  fi

  local cmd_in="$1"; shift
  local cmd; cmd=$(resolve_cmd "$cmd_in")

  # Load modules after resolving config
  load_modules

  # register subcommands
  if [ "$cmd" = "register" ]; then
    local sub="${1:-list}"; shift || true
    case "$sub" in
      list)
        if declare -F cmd_register_list >/dev/null; then
          cmd_register_list "$@"
          exit $?
        else
          err "register.list não disponível (module register não carregado)"
          exit 2
        fi
        ;;
      info)
        if declare -F cmd_register_info >/dev/null; then
          cmd_register_info "$@"
          exit $?
        else
          err "register.info não disponível (module register não carregado)"
          exit 2
        fi
        ;;
      *)
        err "Subcomando register desconhecido: $sub"
        usage; exit 2
        ;;
    esac
  fi

  # Dispatch to module exposed functions (cmd_<name>)
  case "$cmd" in
    help) usage; exit 0 ;;
    fetch|build|install|remove|upgrade|update|deps|full|list|service|sync)
      local fn="cmd_${cmd}"
      if declare -F "$fn" >/dev/null; then
        "$fn" "$@"; exit $?
      else
        err "Comando '$cmd' não implementado (módulo ausente?)"
        exit 2
      fi
      ;;
    *)
      err "Comando desconhecido: $cmd_in"
      usage; exit 2
      ;;
  esac
}

main "$@"
